<!DOCTYPE html>
<html>

<head>
<title> Quantum States for Quantum Computing </title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>

@font-face 
{
  font-family: 'CMU Serif Roman';
  font-style: normal;
  font-weight: normal;
  src: local('CMU Serif Roman'), url('resources/computer-modern/cmunrm.woff') format('woff');
}
    
@font-face
{
  font-family: 'CMU Serif Italic';
  font-style: normal;
  font-weight: normal;
  src: local('CMU Serif Italic'), url('resources/computer-modern/cmunti.woff') format('woff');
}
    
@font-face 
{
  font-family: 'CMU Serif Bold';
  font-style: normal;
  font-weight: normal;
  src: local('CMU Serif Bold'), url('resources/computer-modern/cmunbx.woff') format('woff');
}

@font-face
{
  font-family: 'CMU Serif BoldItalic';
  font-style: normal;
  font-weight: normal;
  src: local('CMU Serif BoldItalic'), url('resources/computer-modern/cmunbi.woff') format('woff');
}

body 
{
  font-family: "CMU Serif Roman";
}

.sidenav
{
  width     : 150px;
  position  : fixed;
  z-index   : 1;
  top       : 50px;
  left      : 10px;
  background: #eee;
  overflow-x: hidden;
  padding   : 8px 0;
}

.sidenav a
{
  padding        : 6px 8px 6px 16px;
  text-decoration: none;
  font-size      : 20px;
  color          : #2196F3;
  display        : block;
}

.sidenav-h
{
  padding        : 6px 8px 6px 16px;
  text-decoration: none;
  font-size      : 20px;
  color          : #2196F3;
  display        : block;
}

.sidenav a:hover 
{
  color: #064579;
}

a
{
  text-decoration: none;
}

.main {
  margin-left : 200px; /* Same width as the sidebar + left position in px */
  font-size   : 25px; /* Increased text to enable scrolling */
  padding     : 0px 10px;
}

@media screen and (max-height: 450px) {
  .sidenav {padding-top: 15px;}
  .sidenav a {font-size: 18px;}
}
</style>
</head>
<body>

<div class="sidenav">
  <div class="sidenav-h">  <b> SECTIONS</b> </div>
  <a href="#bit">          Classical Bit </a>
  <a href="#qubit">        Quantum Bit    </a>
  <a href="#qstates">      Quantum States </a>
  <a href="#entanglement"> Entanglement  </a>
  <div class="sidenav-h">  <b> APPENDIX</b> </div>
  <a href="#complex"> Complex Numbers  </a>
</div>

<div class="main">

<!------------------------------------------------------------------------------------------------->
<center>
<h1> Quantum States for Quantum Computing </h1>
Prepared by: <i> Ren Tristan A. de la Cruz</i> <br>
Updated on:  <i> 2023 September 07 </i>
</center>

<!------------------------------------------------------------------------------------------------->
<hr>
<b>Notes:</b> 
<ul>
<li>
This quantum computing web notebook is inspired by the
<i> <a href="https://womanium.org/Quantum/Program">Womanium</a> Global Quantum Project</i>. The idea
behind this quantum computing web notebook is to publicly share my notes while on the process of 
learning quantum computing.
</li>

<li>
Currently, this page (<i>Quantum States for Quantum Computing</i>) is the only page in the
quantum computing web notebook. I am planning to add more pages on different quantum computing topics
when I have the time. 
</li>

<li style="color:red">
This page (<i>Quantum States for Quantum Computing</i>) is still incomplete. I will update it when I
have the time.
</li>

<li>
If you find incorrect or inaccurate information and want me to correct them, you can email me at
<i>rentristandelacruz [at] gmail [dot] com</i> or click <a href="mailto:rentristandelacruz@gmail.com">
here</a>.
</li>
</ul>

<hr>

<!------------------------------------------------------------------------------------------------->
<br>
<h2> Introduction </h2>
<hr>

<p>
Computation is information processing. In classical computing, information is encoded into strings 
of bits called <i>bit strings</i>. Bit strings are the objects of computation in classical computing.
Bit strings are the ones being processed (checked and transformed) during computation. In quantum
computing, the objects of computation are <i>quantum states</i>. In a similar manner to how a bit 
string is made up of multiple bits, a quantum state is made up of multiple <i>quantum bits (qubits).
</i> This web note is about quantum states used for quantum computing. 
</p>

<!------------------------------------------------------------------------------------------------->
<br>
<h2 id="bit"> 
Classical Bit 
</h2>
<hr>

<p>
The <i> classical bit</i> is the smallest unit of information. It is the amount of information you 
gain when you received an answer to a <i> yes-or-no </i> question where it is equally likely for
the answer to be a 'yes' or a 'no'. It is also amount of information you gain when the result of a
fair coin toss is revealed to you. The classical bit specifies which one of the two possible options 
occurred or was selected. 
</p>

<p>
The term <i> bit </i> is the contraction of "binary digit". Digits \( \texttt{0} \) and 
\( \texttt{1} \) are often used as the values of the classical bit. Digit \( \texttt{0} \) 
represents one of the two possible options while the digit \( \texttt{1} \) represents the other 
option. Alternative pairs of values like <i>false-true</i>, <i>off-on</i>, and <i>low-high</i> are
also used as values for the classical bit.
</p>

<p>
One <i>bit</i> of information can be stored in any system that has two distinguishable states. We 
call such systems as <i>two-state classical</i> systems. e.g. A physical on/off switch is a 
two-state system where the two states are <i>on</i> and <i>off</i>. A punched card, or specifically 
a position/location on a punched card, is a two-state system where the two states are 
<i>punched</i> (has hole) and <i>non-punched</i> (no hole). The punched card as a whole contains 
many of these two-state 'systems' and thus stores multiple bits of information.
</p>

<!------------------------------------------------------------------------------------------------->
<h3> Bit Strings </h3>

<p>
To represent multiple bits of information, bits can be stringed together to form a <i>bit string</i>
(also called <i>binary strings</i>). Bit strings are needed to represent states of a system with
more than two states. For example, for a system that can be in one of four possible states \( A, B,
C, D \),  2-bit strings are needed in order to represent the four states. i.e Bit string \(00\) can 
represent state \(A\),  \(01\) can represent state \(B\), \(10\) can represent state \(C\), and 
\(11\) can represent state \(D\). In general, if a system has \(X\) possible states, then you need
around \(log_2(X)\) bits to represent the states of the system. More precisely:
</p>

$$
\text{number of bits } = \lceil log_2(\text{number of possible options or states}) \rceil
$$

<p>
For example, after rolling a six-sided, it will be in one of the following six states: 
\(1,2,3,4,5,6\). Since \( log_2(6) \approx 2.58496 \), you need \(3 = \lceil log_2(6) \rceil \) bits
to represent the six possible states of the die. i.e. String \(000\) represents state \(1\), \(001\) 
represents state \(2\), \(010\) represents state \(3\), \(011\) represents state \(4\), \(100\)
represents state \(5\), \(101\) represents state \(6\), while strings \(110\) and \(111\) do not
represent any possible die states. \(3\)-bit strings can represent 8 states while \(2\)-bit strings
can only represent 4 states and so we need 3 bits to represent that states of the die.  
</p>

<p>
<b>Some Formalism:</b> The set \(\Sigma = \{0, 1\}\) is the <i>alphabet</i> of the bit strings. The
concatenation operation \(|\) can take two bits \(b_1, b_2 \in \Sigma\) and form the 2-bit string
\(b_1|b_2\) or simply \(b_1b_2\). e.g If \(b_1=0\) and \(b_2=1\), then \(b_1|b_2 = b_1b_2 = 01\).
If \(b_1=1\) and \(b_2=1\), the \(b_1|b_2 = b_1b_2 = 11\). The concatenation operation can also 
string together bit strings (not only bits). e.g. If \(B_1 = 101\)  and \(B_2 = 111\)$, then 
\(B_1 | B_2 = B_1B_2 = 101111\). The <i>length</i> of a bit string is the number of bits is has. The 
symbol \(\lambda\), or sometimes \(\varepsilon\), denotes the <i>empty string</i>, the string with 
no symbols (bits). The set \(\Sigma^* = \{\lambda, 0,1,00,01,10,11,...\}\), pronounced as 
`sigma star`, is the set of all bit string of any length which includes the empty string. The 
set \(\Sigma^+ =\{0,1,00,01,10,11,...\}\), pronounced as `sigma plus`, is the set of all strings of
any length excluding the empty string. The set \(\Sigma^n\) is the set of all bit strings of length
\(n\). i.e. \(\Sigma^2 = \{00,01,10,11\} \).
</p>

<!------------------------------------------------------------------------------------------------->
<br>
<h2 id="qubit"> 
Quantum Bit (Qubit) <span style="color:red">[Work in Progress]</span>
</h2>
<hr>

<p>
If the classical bit is the information stored in a two-state classical system, then the 
<i> quantum bit (or qubit) </i> is the information stored in a <i>two-state quantum</i> system. In
a two-state quantum system, there is also a set with two states called the <i>basis</i>. Let the set
\(\{\ket{A}, \ket{B}\}\) be basis of the two-state quantum system. This means that if we observe the
quantum system to determine its state, we will either observe the system in state \(\ket{A}\) or 
observe the system in state \(\ket{B}\). The state \(\ket{A}\) is pronounced as `ket A` while state
\(\ket{B}\) is pronounced as `ket B`. This way of writing states is part of the 
<a href="https://en.wikipedia.org/wiki/Bra%E2%80%93ket_notation"><i>bra-ket notation</i></a> created
by the physicist <a href="https://en.wikipedia.org/wiki/Paul_Dirac"><i>Paul Dirac</i></a>. When you see
these <i>ket</i> notations, you know you will be dealing with quantum states and not classical 
states.
</p>

<!------------------------------------------------------------------------------------------------->

<h3> Superposition </h3>

Similar to a two-state classical system, when a two-state quantum system is observed/measured it will
either be in state \(\ket{A}\) or in state \(\ket{B}\), given the system basis is \(\{\ket{A}, 
\ket{B}\}\). The quantum system has definite state when observed. But unlike a classical system, 
prior to measurement the state of a two-level quantum system can actually be "indefinite". This 
notion is known as <a href="https://en.wikipedia.org/wiki/Quantum_indeterminacy">
<i>quantum indeterminacy</i></a>. 



<br> <br>

The classical bit specifies the definite state of a two-state classical system.  

$$
\ket{\psi} = \alpha \ket{0} + \beta \ket{1}
$$

<b>Born Rule:</b>

$$
|\alpha|^2 + |\beta|^2 = 1
$$

fdsfsdf

<div align="center">
  <img   src="figures/qs-amplitudes.svg" 
         alt="Representation of the Born Rule"
       align="center"
       width="550"/>
</div>

fdsfsd

<div align="center">
  <img   src="figures/qs-circle.svg" 
         alt="Using a Single Angle to Define Amplitudes"
       align="center"
       width="550"/>
</div>

$$
\ket{\psi_\theta} = cos(\theta)\ket{0} + sin(\theta)\ket{1}
$$

<div align="center">
  <img   src="figures/qs-blochsphere.svg" 
         alt="Bloch Sphere"
       align="center"
       width="550"/>
</div>


<!------------------------------------------------------------------------------------------------->
<h3> Qubit Examples </h3>

<style>
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
  text-align: center;
  padding: 10px;
}
</style>

<center>
<table style="width:70%">
  <tr>
    <th rowspan="2"> Qubit State </th>
    <th colspan="2">Amplitude of Basis:</th>
    <th colspan="2">Probability of Basis:</th>
  </tr>
  <tr>
    <td> \( \ket{0}\) </td>
    <td> \( \ket{1}\) </td>
    <td> \( \ket{0}\) </td>
    <td> \( \ket{1}\) </td>
  </tr>
  <tr>
    <td> \( \ket{\psi_1}  = 1 \ket{0} + 0 \ket{1} = \ket{0} \) </td>
    <td> 1 </td>
    <td> 0 </td>
    <td> \( \left| 1 \right|^2 = 1\) </td>
    <td> \( \left| 0 \right|^2 = 0\) </td>
  </tr>
  <tr>
    <td> \( \ket{\psi_2}  = 0 \ket{0} + 1 \ket{1} = \ket{1} \) </td>
    <td> 0 </td>
    <td> 1 </td>
    <td> \( \left| 0 \right|^2 = 0\) </td>
    <td> \( \left| 1 \right|^2 = 1\) </td>
  </tr>
  <tr>
    <td> \( \ket{\psi_3}  = \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}}  \ket{1} \) </td>
    <td> \( \frac{1}{\sqrt{2}} \) </td>
    <td> \( \frac{1}{\sqrt{2}} \) </td>
    <td> \( \left|\frac{1}{\sqrt{2}}\right|^2 =  \frac{1}{2} \) </td>
    <td> \( \left|\frac{1}{\sqrt{2}}\right|^2 =  \frac{1}{2} \) </td>
  </tr>
  <tr>
    <td> \( \ket{\psi_4}  = \frac{1}{\sqrt{4}} \ket{0} + \frac{\sqrt{3}}{\sqrt{4}}  \ket{1} \) </td>
    <td> \( \frac{1}{\sqrt{4}} \) </td>
    <td> \( \frac{\sqrt{3}}{\sqrt{4}} \) </td>
    <td> \( \left|\frac{1}{\sqrt{4}}\right|^2 =  \frac{1}{4} \) </td>
    <td> \( \left|\frac{\sqrt{3}}{\sqrt{4}}\right|^2 =  \frac{3}{4} \) </td>
  </tr>
  <tr>
    <td> \( \ket{\psi_5}  = \frac{\sqrt{5}}{\sqrt{8}} \ket{0} + \frac{\sqrt{3}}{\sqrt{8}}  \ket{1} \) </td>
    <td> \( \frac{\sqrt{5}}{\sqrt{8}} \) </td>
    <td> \( \frac{\sqrt{3}}{\sqrt{8}} \) </td>
    <td> \( \left|\frac{\sqrt{5}}{\sqrt{8}}\right|^2 =  \frac{5}{8} \) </td>
    <td> \( \left|\frac{\sqrt{3}}{\sqrt{8}}\right|^2 =  \frac{3}{8} \) </td>
  </tr>
</table>
</center>

<!------------------------------------------------------------------------------------------------->
<h3> Qubits as Vectors </h3>

$$
\ket{\psi} = cos(\frac{\theta}{2})\ket{0} + e^{i\phi} sin(\frac{\theta}{2}) i \ket{1}
$$

The qubit \( \ket{0} \) can be represented by the column vector:

$$
\ket{0} 
= 
\begin{bmatrix}
  1 \\
  0
\end{bmatrix}
$$


The qubit \( \ket{1} \) can be represented by the column vector:

$$
\ket{1}
=
\begin{bmatrix}
  0 \\
  1
\end{bmatrix}
$$


The generic qubit \( \ket{\psi} =  \alpha\ket{0} + \beta\ket{1} \) can be represented by column
vector:

$$
\ket{\psi}
=
\begin{bmatrix}
  \alpha \\
  \beta
\end{bmatrix}
=
\alpha
\begin{bmatrix}
  1 \\
  0
\end{bmatrix}
+
\beta
\begin{bmatrix}
  0 \\
  1
\end{bmatrix}
$$

<!------------------------------------------------------------------------------------------------->
<h3> Qubits as Binary Trees </h3>

Horizontal tree

<div align="center">
  <img   src="figures/qs-1qubit-htree.svg" 
         alt="Qubit as Horizontal Binary Tree"
       align="center"
       width="250 "/>
</div>

Vertical Tree

<div align="center">
  <img   src="figures/qs-1qubit-vtree.svg" 
         alt="Qubit as a Vertical Binary Tree"
       align="center"
       width="300 "/>
</div>

<!------------------------------------------------------------------------------------------------->
<br>
<h2 id="qstates"> 
Quantum States  <span style="color:red">[Work in Progress]</span>
</h2>
<hr>

Horizontal Tree

<div align="center">
  <img   src="figures/qs-2qubit-htree.svg" 
         alt="2-qubit State as a Horizontal Binary Tree"
       align="center"
       width="400 "/>
</div>

Vertical Binary Tree

<div align="center">
  <img   src="figures/qs-2qubit-vtree.svg" 
         alt="2-qubit State as a Vertical Binary Tree"
       align="center"
       width="450 "/>
</div>


<br>

Let the first qubit be \(\ket{q_1}\):

$$
\ket{q_1} = \alpha \ket{0} + \beta \ket{1} 
          = \begin{bmatrix}
              \alpha \\
              \beta
            \end{bmatrix}
$$

Let the second qubit be \(\ket{q_2}\):

$$
\ket{q_2} = \gamma \ket{0} + \delta \ket{1}
          = \begin{bmatrix}
              \gamma \\
              \delta
            \end{bmatrix}
$$

The tensor product of \(\ket{q_1}\) and \(\ket{q_2}\), denoted by \(\ket{q_1} \otimes \ket{q_2}\) 
(or simply \(\ket{q_1q_2}\) ), is computed as follows:
$$
\begin{align*}
\ket{q_1} \otimes \ket{q_2} &= \ket{q_1q_2}  \\
                            &= (\alpha \ket{0} + \beta \ket{1})  \otimes 
                               (\gamma \ket{0} + \delta\ket{1}) \\
                            &= [(\alpha \ket{0}) \otimes (\gamma \ket{0} + \delta \ket{1})] +
                               [(\beta  \ket{1}) \otimes (\gamma \ket{0} + \delta \ket{1})] \\
                            &= [\alpha \gamma \ket{00} + \alpha \delta \ket{01}] + 
                               [\beta  \gamma \ket{10} + \beta  \delta \ket{11}] \\ 
                            &= \alpha \gamma \ket{00} + \alpha \delta \ket{01} + 
                               \beta  \gamma \ket{10} + \beta  \delta \ket{11} \\ 
\end{align*}
$$

As column vectors:

$$
\begin{align*}
\ket{q_1q_2} &= \ket{q_1} \otimes \ket{q_2} \\
             &= \begin{bmatrix}
                \alpha \\
                \beta  
                \end{bmatrix}
                \otimes
                \begin{bmatrix}
                \gamma \\
                \delta 
                \end{bmatrix} \\
             &= \begin{bmatrix}
                \alpha \begin{bmatrix}
                       \gamma \\
                       \delta
                       \end{bmatrix} \\
                \beta  \begin{bmatrix}
                       \gamma \\
                       \delta
                       \end{bmatrix}
                \end{bmatrix}
              = \begin{bmatrix}
                \alpha \cdot \gamma \\
                \alpha \cdot \delta \\
                \beta  \cdot \gamma \\
                \beta \cdot \delta
                \end{bmatrix} \\
             &= \begin{bmatrix}
                \alpha \gamma \\
                \alpha \delta \\
                \beta  \gamma \\
                \beta  \delta
                \end{bmatrix}
\end{align*}
$$

<!------------------------------------------------------------------------------------------------->
<br>
<h2 id="entanglement">
Entanglement of Qubits <span style="color:red">[Work in Progress]</span>
</h2>
<hr>


Non-entangled 3-qubit state:

<div align="center">
  <img   src="figures/qs-3qubit-non-entangled.svg" 
         alt="Non-entangled 3-qubit State"
       align="center"
       width="700"/>
</div>
<br>

Entanglement \(q_1 = q_3\):

<div align="center">
  <img   src="figures/qs-3qubit-q1-eq-q3.svg" 
         alt="3-qubit State with Entanglement q1=q3"
       align="center"
       width="700"/>
</div>
<br>

Entanglement \(q_1 \neq q_2\):

<div align="center">
  <img   src="figures/qs-3qubit-q1-neq-q2.svg" 
         alt="3-qubit State with Entanglement q1 =\= q2"
       align="center"
       width="700"/>
</div>
<br>

Entanglement \(q_1 = q_2 = q_3\):

<div align="center">
  <img   src="figures/qs-3qubit-eq-q123.svg" 
         alt="3-qubit State with Entanglement q1 = q2 = q3"
       align="center"
       width="700"/>
</div>
<br>




<!------------------------------------------------------------------------------------------------->
<h1>
Appendix
</h1>
<hr>

<!------------------------------------------------------------------------------------------------->
<h2 id="complex">
Complex Numbers
</h2>

<p>
The set \(\mathbb{C}\) of <i>complex numbers</i> is an extension of the set \(\mathbb{R}\) of 
<i>real</i> numbers. A complex number \(z\) has the form:

$$
z = a + bi
$$

where \(a,b \in \mathbb{R}\) are real numbers and \(i = \sqrt{-1}\) is the <i>imaginary unit</i>. We
denote the real component of the complex number \(z\) as \(Re(z)\) while the imaginary component is 
denoted as \(Im(z)\). i.e. Given \(z=a+bi\), \(Re(z) = a\) and \(Im(z)=b\).
</p>

<p>
A complex number can be represented as a point in a two-dimensional plane called the 
<i>Argand plane</i>. Conventionally, the horizontal axis of the plane represents the real component
of the complex number while the vertical component represents the imaginary component of the 
complex number. The complex number \(z = a+bi \) is represented as the point \((a,b)\) on  the 
plane.

<div align="center">
  <img   src="figures/comp-argand.svg" 
         alt="Argand Plane"
       align="center"
       width="450"/>
</div>
</p>

<p>
The <i>modulus</i> (or <i>absolute value</i>) of the complex number \(z = a + bi\) is the real 
number is:

$$
|z| = \sqrt{Re(z)^2 + Im(z)^2} = \sqrt{a^2+b^2}
$$
The modulus is the distance from the origin \((0,0)\) to the point \((a,b)\) that represents \(z\).
</p>

<p>
The <i>complex conjugate</i> of the complex number \(z = a + bi\), denoted as \(z^*\) (or 
sometimes \(\overline{z}\)), is the complex number:
$$
z^* = a - bi
$$
</p>

<p>
The <i>square modulus</i> of the complex number \(z=a+bi\), denoted as \(|z|^2\), is simply the 
square of its modulus.

$$
|z|^2 = Re(z)^2 + Im(z)^2 = a^2+b^2
$$

Another way of computing the square modulus is by multiplying \(z\) with its complex conjugate 
\(z^*\).

$$
\begin{align*}
|z|^2 = zz^* &= (a+bi)(a-bi) \\
             &= a^2 + abi - abi - (bi)^2 \\
             &= a^2 -(i)^2b^2 \\
             &= a^2 -(-1)b^2 \\
             &= a^2 + b^2
\end{align*}
$$
</p>

<!------------------------------------------------------------------------------------------------->
</div>  

</body>
</html> 

